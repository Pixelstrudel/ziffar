<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ziffar - Das Würfelspiel</title>
    <meta name="description"
        content="Ein Yahtzee-ähnliches Würfelspiel für mehrere Spieler im Hot-Seat-Modus mit Spielhistorie und dynamischem Design.">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="manifest" href="manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <style>
        /* --- Material You Inspired Theme --- */
        :root {
            /* Helle Variante (Default) */
            --primary: #6750A4;
            --on-primary: #FFFFFF;
            --primary-container: #EADDFF;
            --on-primary-container: #21005D;
            --secondary: #625B71;
            --on-secondary: #FFFFFF;
            --secondary-container: #E8DEF8;
            --on-secondary-container: #1D192B;
            --tertiary: #7D5260;
            --on-tertiary: #FFFFFF;
            --tertiary-container: #FFD8E4;
            --on-tertiary-container: #31111D;
            --error: #B3261E;
            --on-error: #FFFFFF;
            --error-container: #F9DEDC;
            --on-error-container: #410E0B;
            --background: #FFFBFE;
            --on-background: #1C1B1F;
            --surface: #FFFBFE;
            --on-surface: #1C1B1F;
            --surface-variant: #E7E0EC;
            --on-surface-variant: #49454F;
            --outline: #79747E;
            --outline-variant: #C4C6C9;
            --shadow: #000000;
            --surface-container-highest: #E6E0E9;
            --surface-container-high: #ECE6F0;
            --surface-container: #F3EDF7;
            --surface-container-low: #F7F2FA;
            --surface-container-lowest: #FFFFFF;
            /* +++ NEW: Responsive Dice Size Variables +++ */
            --dice-size: 40px; /* Default size for mobile */
            --pip-size: 6px;   /* Default size for mobile */
            --border-radius-sm: 4px;
            --border-radius-md: 8px;
            --border-radius-lg: 12px;
            --border-radius-xl: 16px;
            --border-radius-full: 9999px;
            --transition-duration: 0.2s;
            --transition-timing: ease-in-out;
            --oled-bg: #000000;
        }

        /* +++ NEW: Larger Dice Size for Medium Screens & Up +++ */
        @media (min-width: 768px) {
            :root {
                --dice-size: 50px; /* Larger size for desktop */
                --pip-size: 8px;   /* Larger size for desktop */
            }
        }


        html.dark {
            /* Dunkle Variante (remains unchanged) */
            --primary: #D0BCFF;
            --on-primary: #381E72;
            --primary-container: #4F378B;
            --on-primary-container: #EADDFF;
            --secondary: #CCC2DC;
            --on-secondary: #332D41;
            --secondary-container: #4A4458;
            --on-secondary-container: #E8DEF8;
            --tertiary: #EFB8C8;
            --on-tertiary: #492532;
            --tertiary-container: #633B48;
            --on-tertiary-container: #FFD8E4;
            --error: #F2B8B5;
            --on-error: #601410;
            --error-container: #8C1D18;
            --on-error-container: #F9DEDC;
            --background: var(--oled-bg);
            --on-background: #E6E1E5;
            --surface: #141218;
            --on-surface: #E6E1E5;
            --surface-variant: #49454F;
            --on-surface-variant: #CAC4D0;
            --outline: #938F99;
            --outline-variant: #444746;
            --shadow: #000000;
            --surface-container-highest: #36343B;
            --surface-container-high: #2B2930;
            --surface-container: #211F26;
            --surface-container-low: #1D1B20;
            --surface-container-lowest: #0F0D13;
        }

        /* General Styles (mostly unchanged) */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background);
            color: var(--on-background);
            overscroll-behavior-y: contain;
            transition: background-color var(--transition-duration) var(--transition-timing), color var(--transition-duration) var(--transition-timing);
        }

        .card {
            background-color: var(--surface);
            color: var(--on-surface);
            border-radius: var(--border-radius-xl);
            box-shadow: 0 4px 6px -1px rgba(var(--shadow), 0.1), 0 2px 4px -1px rgba(var(--shadow), 0.06);
            transition: background-color var(--transition-duration) var(--transition-timing), color var(--transition-duration) var(--transition-timing);
            border: 1px solid var(--outline-variant);
        }

        .card-header {
            background-color: var(--surface-container-low);
            color: var(--on-surface-variant);
            border-bottom: 1px solid var(--outline-variant);
            padding: 1rem 1.5rem;
            border-top-left-radius: var(--border-radius-xl);
            border-top-right-radius: var(--border-radius-xl);
        }

        .card-body {
            padding: 1.5rem; /* Main padding for the card content area */
        }

        .card-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--outline-variant);
            background-color: var(--surface-container-lowest);
            border-bottom-left-radius: var(--border-radius-xl);
            border-bottom-right-radius: var(--border-radius-xl);
        }

        /* Dice Styles (use CSS variables for size) */
        .dice {
            width: var(--dice-size); /* Uses variable */
            height: var(--dice-size);/* Uses variable */
            background-color: var(--surface-container-highest);
            border: 1px solid var(--outline);
            border-radius: var(--border-radius-md);
            padding: 4px;
            display: grid;
            grid-template-areas: "a . c" "e g f" "d . b";
            box-shadow: 0 1px 3px rgba(var(--shadow), 0.1), 0 1px 2px rgba(var(--shadow), 0.06);
            cursor: pointer;
            transition: all var(--transition-duration) var(--transition-timing);
            position: relative;
            color: var(--on-surface);
        }
        .pip {
            width: var(--pip-size); /* Uses variable */
            height: var(--pip-size);/* Uses variable */
            background-color: var(--on-surface-variant);
            border-radius: 50%;
            align-self: center;
            justify-self: center;
            display: none;
            transition: background-color var(--transition-duration) var(--transition-timing);
        }
        .dice.held { background-color: var(--primary-container); border-color: var(--primary); box-shadow: 0 0 0 3px var(--primary); }
        .dice:not(.held):hover { transform: scale(1.05); box-shadow: 0 4px 8px rgba(var(--shadow), 0.15); border-color: var(--primary); }
        .dice.rolling { animation: roll 0.5s ease-in-out; }
        @keyframes roll { 0% { transform: rotate(0deg) scale(1); opacity: 0.8; } 25% { transform: rotate(15deg) scale(1.1); opacity: 1; } 50% { transform: rotate(-10deg) scale(0.9); } 75% { transform: rotate(5deg) scale(1.05); } 100% { transform: rotate(0deg) scale(1); opacity: 1; } }
        /* Pip visibility rules (unchanged) */
        .dice[data-value="1"] .pip.center, .dice[data-value="3"] .pip.center, .dice[data-value="5"] .pip.center { display: block; grid-area: g; }
        .dice[data-value="2"] .pip.top-left, .dice[data-value="3"] .pip.top-left, .dice[data-value="4"] .pip.top-left, .dice[data-value="5"] .pip.top-left, .dice[data-value="6"] .pip.top-left { display: block; grid-area: a; }
        .dice[data-value="2"] .pip.bottom-right, .dice[data-value="3"] .pip.bottom-right, .dice[data-value="4"] .pip.bottom-right, .dice[data-value="5"] .pip.bottom-right, .dice[data-value="6"] .pip.bottom-right { display: block; grid-area: b; }
        .dice[data-value="4"] .pip.top-right, .dice[data-value="5"] .pip.top-right, .dice[data-value="6"] .pip.top-right { display: block; grid-area: c; }
        .dice[data-value="4"] .pip.bottom-left, .dice[data-value="5"] .pip.bottom-left, .dice[data-value="6"] .pip.bottom-left { display: block; grid-area: d; }
        .dice[data-value="6"] .pip.middle-left { display: block; grid-area: e; }
        .dice[data-value="6"] .pip.middle-right { display: block; grid-area: f; }

        /* Button Styles (unchanged) */
        .btn { padding: 10px 24px; border: none; border-radius: var(--border-radius-full); font-weight: 500; cursor: pointer; transition: background-color var(--transition-duration) var(--transition-timing), box-shadow var(--transition-duration) var(--transition-timing), transform 0.1s ease; box-shadow: 0 1px 2px 0 rgba(var(--shadow), 0.05); text-align: center; display: inline-block; }
        .btn-primary { background-color: var(--primary); color: var(--on-primary); }
        .btn-primary:hover:not(:disabled) { box-shadow: 0 4px 8px rgba(var(--primary), 0.3); filter: brightness(1.1); }
        .btn-primary:active:not(:disabled) { transform: scale(0.97); }
        .btn-primary:disabled { background-color: var(--on-surface); color: var(--surface); opacity: 0.38; cursor: not-allowed; box-shadow: none; filter: none; }
        .btn-secondary { background-color: var(--secondary-container); color: var(--on-secondary-container); }
        .btn-secondary:hover:not(:disabled) { box-shadow: 0 2px 4px rgba(var(--secondary), 0.2); filter: brightness(0.95); }
        .btn-secondary:active:not(:disabled) { transform: scale(0.97); }
        .btn-secondary:disabled { background-color: var(--on-surface); color: var(--surface); opacity: 0.38; cursor: not-allowed; box-shadow: none; filter: none; }
        .btn-icon { background: none; border: none; color: var(--on-surface-variant); padding: 8px; border-radius: 50%; cursor: pointer; transition: background-color var(--transition-duration) var(--transition-timing), color var(--transition-duration) var(--transition-timing); }
        .btn-icon:hover { background-color: rgba(var(--on-surface-variant), 0.1); color: var(--on-surface); }

        /* Scorecard Styles (unchanged) */
        .scorecard-container { overflow-x: auto; border: 1px solid var(--outline-variant); border-radius: var(--border-radius-lg); background-color: var(--surface-container); }
        #scorecard { width: 100%; text-align: left; color: var(--on-surface-variant); border-collapse: collapse; }
        #scorecard thead { background-color: var(--surface-container-high); color: var(--on-surface-variant); }
        #scorecard th, #scorecard td { padding: 0.75rem 1rem; vertical-align: middle; border-bottom: 1px solid var(--outline-variant); }
        #scorecard tbody tr:last-child td, #scorecard tbody tr:last-child th { border-bottom: none; }
        #scorecard th { font-weight: 500; text-transform: none; }
        #scorecard th:first-child, #scorecard td:first-child { position: sticky; left: 0; background-color: inherit; z-index: 10; font-weight: 500; color: var(--on-surface); white-space: normal; border-right: 1px solid var(--outline-variant); }
        #scorecard thead th:first-child { z-index: 11; }
        #scorecard tfoot { background-color: var(--primary-container); color: var(--on-primary-container); font-weight: bold; }
        #scorecard tfoot td, #scorecard tfoot th { border-top: 1px solid var(--outline); border-bottom: none; }
        #scorecard tfoot th:first-child { background-color: var(--primary-container); }
        .score-cell { cursor: pointer; transition: background-color var(--transition-duration) var(--transition-timing), color var(--transition-duration) var(--transition-timing), opacity var(--transition-duration) var(--transition-timing); text-align: center; font-weight: 400; }
        .score-cell.available { color: var(--on-surface-variant); opacity: 0.7; }
        .score-cell.available:hover { background-color: rgba(var(--primary), 0.08); opacity: 1; }
        .score-cell.filled { cursor: default; font-weight: 700; color: var(--on-surface); background-color: var(--surface-container); opacity: 1; }
        .score-cell.filled.current-player-column { background-color: rgba(var(--primary), 0.15) !important; }
        .score-cell.potential { background-color: var(--secondary-container); color: var(--on-secondary-container); font-style: italic; font-weight: 300; opacity: 1; }
        .score-cell.potential:hover { filter: brightness(0.95); }
        .category-description { display: block; font-size: 0.75rem; line-height: 1rem; color: var(--on-surface-variant); font-weight: 400; margin-top: 0.1rem; }
        .score-section-header { background-color: var(--surface-container-low); font-weight: 500; color: var(--primary); text-align: left; }
        .score-section-header td { padding: 0.5rem 1rem; position: sticky; left: 0; z-index: 10; border-right: 1px solid var(--outline-variant); }
        .current-player-column { background-color: rgba(var(--primary), 0.12) !important; }
        th.current-player-column { background-color: var(--primary-container) !important; color: var(--on-primary-container); }
        tfoot td.current-player-column { background-color: var(--primary) !important; color: var(--on-primary); }

        /* Game Info Styles (Adjusted for responsiveness) */
        #gameInfo { text-align: center; } /* Centered by default (mobile) */
        #gameInfo #currentPlayerName { color: var(--primary); font-weight: 700; }
        @media (min-width: 768px) {
            #gameInfo { text-align: left; } /* Align left on larger screens */
        }

        /* Player Setup Styles (unchanged) */
        #playerSetup { background-color: var(--surface-container-lowest); }
        label { color: var(--on-surface-variant); font-size: 0.875rem; margin-bottom: 0.25rem; display: block; }
        input[type="text"], select { width: 100%; padding: 0.75rem 1rem; border: 1px solid var(--outline); border-radius: var(--border-radius-sm); background-color: var(--surface-container-high); color: var(--on-surface); transition: border-color var(--transition-duration) var(--transition-timing), background-color var(--transition-duration) var(--transition-timing); }
        input[type="text"]:focus, select:focus { outline: 2px solid var(--primary); outline-offset: 1px; border-color: var(--primary); }

        /* Game Over Styles (unchanged) */
        #gameOverOverlay { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 100; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        #gameOverOverlay.show { opacity: 1; visibility: visible; }
        #gameOverContent { background-color: var(--surface-container-high); color: var(--on-surface); padding: 2rem; border-radius: var(--border-radius-xl); box-shadow: 0 8px 16px rgba(var(--shadow), 0.2); text-align: center; max-width: 90%; width: 400px; }
        #gameOverContent h2 { color: var(--primary); margin-bottom: 1rem; font-size: 1.875rem; font-weight: 700; }
        #gameOverContent #winnerMessage { color: var(--secondary); font-size: 1.125rem; font-weight: 500; margin-bottom: 1.5rem; }

        /* Game History Styles (unchanged) */
        #gameHistorySection { background-color: var(--surface-container-lowest); }
        #historyContent { max-height: 300px; overflow-y: auto; padding: 1rem; border: 1px solid var(--outline-variant); border-radius: var(--border-radius-lg); background-color: var(--surface-container); }
        #historyContent h3 { margin-bottom: 0.75rem; font-size: 1.125rem; font-weight: 500; color: var(--on-surface-variant); }
        #historyContent ul { list-style: none; padding: 0; margin: 0; }
        #historyContent li { border-bottom: 1px solid var(--outline-variant); padding: 0.75rem 0; font-size: 0.875rem; color: var(--on-surface-variant); }
        #historyContent li:last-child { border-bottom: none; }
        #historyContent .history-date { display: block; font-size: 0.75rem; color: var(--on-surface-variant); opacity: 0.8; margin-bottom: 0.25rem; }
        #historyContent .history-winner { font-weight: 500; color: var(--tertiary); }
        #historyStats { margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--outline-variant); }
        #historyStats ul li { border-bottom: none; padding: 0.25rem 0; }

        /* Utility Styles (unchanged) */
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }
        .text-primary { color: var(--primary); }
        .text-secondary { color: var(--secondary); }
        .text-tertiary { color: var(--tertiary); }
        .text-error { color: var(--error); }

        /* +++ UPDATED STICKY HEADER STYLE (More Compact Mobile) +++ */
        #sticky-controls-header {
            position: sticky;
            top: 0;
            z-index: 50;
            background-color: var(--surface-container-high);
            /* Responsive padding: More compact on mobile */
            padding: 0.25rem 0.75rem; /* Reduced padding for mobile */
            box-shadow: 0 2px 4px rgba(var(--shadow), 0.05);
        }
        /* Apply larger padding on medium screens and up */
        @media (min-width: 768px) {
            #sticky-controls-header {
                padding: 0.5rem 1.5rem; /* Restore larger padding for desktop */
            }
        }

    </style>
</head>

<body class="min-h-screen p-4 md:p-8 transition-colors duration-300">

    <div class="container mx-auto max-w-4xl card">
        <header class="flex justify-between items-center p-4 card-header">
            <div>
                <h1 class="text-3xl font-bold text-primary">Ziffar</h1>
                <p class="text-on-surface-variant">Das dynamische Würfelspiel!</p>
            </div>
            <button id="darkModeToggle" class="btn-icon text-xl" aria-label="Dark Mode umschalten">
                <i class="fas fa-sun"></i> </button>
        </header>

        <div class="card-body">
            <section id="playerSetup" class="card p-6 bg-[var(--surface-container-lowest)] mb-6">
                <h2 class="text-xl font-semibold mb-4 text-on-surface">Spieler einrichten</h2>
                <div class="flex flex-col sm:flex-row gap-4 mb-4">
                    <div class="flex-grow">
                        <label for="playerCount">Anzahl Spieler:</label>
                        <select id="playerCount" class="w-full">
                            <option value="1">1 Spieler</option>
                            <option value="2" selected>2 Spieler</option>
                            <option value="3">3 Spieler</option>
                            <option value="4">4 Spieler</option>
                        </select>
                    </div>
                    <div id="playerNamesContainer" class="flex-grow grid grid-cols-1 sm:grid-cols-2 gap-4">
                        </div>
                </div>
                <button id="startGameBtn" class="btn btn-primary w-full sm:w-auto">Spiel starten</button>
            </section>

            <section id="gameHistorySection" class="hidden card p-0 bg-[var(--surface-container-lowest)] mb-6">
                <h3 class="text-lg font-medium p-4 border-b border-[var(--outline-variant)] text-on-surface">
                    Spielhistorie</h3>
                <div id="historyContent" class="p-4 max-h-[300px] overflow-y-auto">
                    <p class="text-center text-on-surface-variant">Noch keine Spiele gespielt.</p>
                </div>
            </section>

            <main id="gameArea" class="hidden space-y-6">

                <div id="sticky-controls-header" class="flex flex-col md:flex-row md:items-center md:justify-between">

                    <section id="gameInfo" class="mb-2 md:mb-0">
                        <p class="text-base font-medium"> <span class="text-on-surface-variant">Spieler:</span>
                            <span id="currentPlayerName" class="font-bold text-primary"></span>
                        </p>
                         <p class="text-xs text-on-surface-variant"> Würfe: <span id="rollsLeft" class="font-semibold">3</span> | Runde: <span
                                id="currentRound" class="font-semibold">1</span> / 13
                        </p>
                    </section>

                    <section id="diceArea" class="flex flex-col items-center md:flex-row md:items-center md:gap-4">
                         <h2 class="hidden md:block text-base font-medium text-on-surface-variant md:order-none">
                            Würfel
                        </h2>
                        <div id="diceContainer" class="flex justify-center gap-2 md:gap-3 flex-wrap mb-2 md:mb-0 md:flex-shrink-0">
                            </div>
                        <button id="rollBtn" class="btn btn-primary">Würfeln</button>
                    </section>
                </div>
                <section id="scorecardArea">
                    <h2 class="text-xl font-semibold mb-3 text-on-surface text-center">Punktekarte</h2>
                    <div class="scorecard-container">
                        <table id="scorecard">
                            <thead class="text-xs uppercase">
                                <tr>
                                    <th scope="col" class="sticky left-0 z-10 align-top">Kategorie</th>
                                    </tr>
                            </thead>
                            <tbody>
                                </tbody>
                            <tfoot>
                                </tfoot>
                        </table>
                    </div>
                    <p class="text-xs text-center mt-2 text-on-surface-variant">Klicke auf eine verfügbare Zelle, um
                        Punkte einzutragen.</p>
                </section>

                <div id="gameMessage" class="text-center font-medium text-error h-6"></div>

            </main>

            <div id="gameOverOverlay" class="hidden">
                <div id="gameOverContent">
                    <h2>Spiel vorbei!</h2>
                    <div id="finalScores" class="mb-6 space-y-2 text-left">
                        </div>
                    <p id="winnerMessage" class="text-xl font-semibold mb-6"></p>
                    <button id="restartGameBtn" class="btn btn-primary">Neues Spiel</button>
                </div>
            </div>
        </div> </div> <script>
        // --- CONFIGURATION ---
        const NUM_DICE = 5; const MAX_ROLLS = 3; const CATEGORIES = [{ id: 'ones', name: 'Einsen', description: 'Nur Einsen zählen', section: 'upper' }, { id: 'twos', name: 'Zweien', description: 'Nur Zweien zählen', section: 'upper' }, { id: 'threes', name: 'Dreien', description: 'Nur Dreien zählen', section: 'upper' }, { id: 'fours', name: 'Vieren', description: 'Nur Vieren zählen', section: 'upper' }, { id: 'fives', name: 'Fünfen', description: 'Nur Fünfen zählen', section: 'upper' }, { id: 'sixes', name: 'Sechsen', description: 'Nur Sechsen zählen', section: 'upper' }, { id: 'threeOfAKind', name: 'Dreierpasch', description: 'Mind. 3 gleiche Würfel. Alle Augen zählen.', section: 'lower' }, { id: 'fourOfAKind', name: 'Viererpasch', description: 'Mind. 4 gleiche Würfel. Alle Augen zählen.', section: 'lower' }, { id: 'fullHouse', name: 'Full House', description: '3 gleiche + 2 gleiche Würfel. 25 Punkte.', section: 'lower' }, { id: 'smallStraight', name: 'Kleine Straße', description: 'Folge von 4 Würfeln (z.B. 1-2-3-4). 30 Punkte.', section: 'lower' }, { id: 'largeStraight', name: 'Große Straße', description: 'Folge von 5 Würfeln (z.B. 1-2-3-4-5). 40 Punkte.', section: 'lower' }, { id: 'ziffar', name: 'Ziffar', description: '5 gleiche Würfel. 50 Punkte.', section: 'lower' }, { id: 'chance', name: 'Chance', description: 'Alle Augen zählen.', section: 'lower' },]; const UPPER_BONUS_THRESHOLD = 63; const UPPER_BONUS_POINTS = 35; const ZIFFAR_BONUS_POINTS = 100; const playerColors = ['#6750A4', '#006D3D', '#B3261E', '#0061A4', '#795548', '#E67C73'];
        // --- DOM ELEMENTS ---
        const htmlElement = document.documentElement; const playerSetupSection = document.getElementById('playerSetup'); const playerCountSelect = document.getElementById('playerCount'); const playerNamesContainer = document.getElementById('playerNamesContainer'); const startGameBtn = document.getElementById('startGameBtn'); const gameHistorySection = document.getElementById('gameHistorySection'); const historyContent = document.getElementById('historyContent'); const gameArea = document.getElementById('gameArea'); const gameInfo = document.getElementById('gameInfo'); const currentPlayerNameSpan = document.getElementById('currentPlayerName'); const rollsLeftSpan = document.getElementById('rollsLeft'); const currentRoundSpan = document.getElementById('currentRound'); const diceContainer = document.getElementById('diceContainer'); const rollBtn = document.getElementById('rollBtn'); const scorecardTable = document.getElementById('scorecard'); const scorecardBody = scorecardTable ? scorecardTable.getElementsByTagName('tbody')[0] : null; const scorecardFoot = scorecardTable ? scorecardTable.getElementsByTagName('tfoot')[0] : null; const gameMessage = document.getElementById('gameMessage'); const gameOverOverlay = document.getElementById('gameOverOverlay'); const finalScoresDiv = document.getElementById('finalScores'); const winnerMessage = document.getElementById('winnerMessage'); const restartGameBtn = document.getElementById('restartGameBtn'); const darkModeToggle = document.getElementById('darkModeToggle'); const themeColorMeta = document.querySelector('meta[name="theme-color"]');
        // --- GAME STATE ---
        let players = []; let currentPlayerIndex = 0; let currentRoll = 0; let round = 1; let diceValues = Array(NUM_DICE).fill(1); let heldDice = Array(NUM_DICE).fill(false); let scores = {}; let potentialScores = {}; let ziffarBonus = {}; let isDarkMode = false;
        // --- LOCAL STORAGE KEYS ---
        const LS_PLAYERS_KEY = 'ziffar_playerNames_v2'; const LS_GAME_HISTORY_KEY = 'ziffar_gameHistory_v2'; const LS_DARK_MODE_KEY = 'ziffar_darkMode';

        // --- HELPER FUNCTIONS (Unchanged) ---
        function hexToHSL(H) { let r = 0, g = 0, b = 0; if (H.length == 4) { r = "0x" + H[1] + H[1]; g = "0x" + H[2] + H[2]; b = "0x" + H[3] + H[3]; } else if (H.length == 7) { r = "0x" + H[1] + H[2]; g = "0x" + H[3] + H[4]; b = "0x" + H[5] + H[6]; } r /= 255; g /= 255; b /= 255; let cmin = Math.min(r, g, b), cmax = Math.max(r, g, b), delta = cmax - cmin, h = 0, s = 0, l = 0; if (delta == 0) h = 0; else if (cmax == r) h = ((g - b) / delta) % 6; else if (cmax == g) h = (b - r) / delta + 2; else h = (r - g) / delta + 4; h = Math.round(h * 60); if (h < 0) h += 360; l = (cmax + cmin) / 2; s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1)); s = +(s * 100).toFixed(1); l = +(l * 100).toFixed(1); return [h, s, l]; }
        function formatHSL(hsl) { return `hsl(${hsl[0]}, ${hsl[1]}%, ${hsl[2]}%)`; }
        function generateThemeColors(baseHex, darkMode = false) { const baseHSL = hexToHSL(baseHex); if (!baseHSL) return {}; const [h, s, l] = baseHSL; const theme = {}; if (darkMode) { theme['--primary'] = formatHSL([h, Math.min(s, 80), Math.min(l + 40, 80)]); theme['--on-primary'] = formatHSL([h, Math.max(s - 30, 10), Math.max(l - 30, 20)]); theme['--primary-container'] = formatHSL([h, Math.min(s, 60), Math.max(l - 20, 25)]); theme['--on-primary-container'] = formatHSL([h, Math.min(s, 90), Math.min(l + 50, 90)]); theme['--secondary'] = formatHSL([(h + 30) % 360, Math.min(s - 10, 50), Math.min(l + 30, 75)]); theme['--on-secondary'] = formatHSL([(h + 30) % 360, Math.max(s - 40, 10), Math.max(l - 20, 20)]); theme['--secondary-container'] = formatHSL([(h + 30) % 360, Math.min(s - 10, 40), Math.max(l - 15, 30)]); theme['--on-secondary-container'] = formatHSL([(h + 30) % 360, Math.min(s, 80), Math.min(l + 45, 90)]); theme['--surface'] = formatHSL([h, Math.min(s, 10), 10]); theme['--on-surface'] = formatHSL([h, Math.min(s, 15), 90]); theme['--surface-variant'] = formatHSL([h, Math.min(s, 15), 25]); theme['--on-surface-variant'] = formatHSL([h, Math.min(s, 15), 80]); theme['--outline'] = formatHSL([h, Math.min(s, 10), 60]); theme['--outline-variant'] = formatHSL([h, Math.min(s, 10), 30]); theme['--background'] = `var(--oled-bg)`; theme['--on-background'] = theme['--on-surface']; theme['--surface-container-lowest'] = formatHSL([h, Math.min(s, 5), 5]); theme['--surface-container-low'] = formatHSL([h, Math.min(s, 10), 12]); theme['--surface-container'] = formatHSL([h, Math.min(s, 10), 15]); theme['--surface-container-high'] = formatHSL([h, Math.min(s, 12), 18]); theme['--surface-container-highest'] = formatHSL([h, Math.min(s, 12), 22]); } else { theme['--primary'] = formatHSL([h, Math.min(s, 70), Math.max(l, 40)]); theme['--on-primary'] = formatHSL([h, Math.min(s, 50), Math.min(l + 50, 100)]); if (l > 65) theme['--on-primary'] = formatHSL([h, Math.min(s, 70), Math.max(l - 50, 10)]); theme['--primary-container'] = formatHSL([h, Math.min(s, 50), Math.min(l + 50, 90)]); theme['--on-primary-container'] = formatHSL([h, Math.min(s, 70), Math.max(l - 25, 20)]); theme['--secondary'] = formatHSL([(h + 60) % 360, Math.max(s - 20, 30), l]); theme['--on-secondary'] = formatHSL([(h + 60) % 360, Math.min(s, 50), Math.min(l + 50, 100)]); if (l > 65) theme['--on-secondary'] = formatHSL([(h + 60) % 360, Math.min(s, 70), Math.max(l - 50, 10)]); theme['--secondary-container'] = formatHSL([(h + 60) % 360, Math.max(s - 20, 40), Math.min(l + 45, 92)]); theme['--on-secondary-container'] = formatHSL([(h + 60) % 360, Math.min(s, 70), Math.max(l - 15, 25)]); theme['--surface'] = formatHSL([h, Math.min(s, 15), 98]); theme['--on-surface'] = formatHSL([h, Math.min(s, 10), 10]); theme['--surface-variant'] = formatHSL([h, Math.min(s, 20), 90]); theme['--on-surface-variant'] = formatHSL([h, Math.min(s, 15), 30]); theme['--outline'] = formatHSL([h, Math.min(s, 10), 50]); theme['--outline-variant'] = formatHSL([h, Math.min(s, 10), 80]); theme['--background'] = formatHSL([h, Math.min(s, 10), 99]); theme['--on-background'] = theme['--on-surface']; theme['--surface-container-lowest'] = formatHSL([h, 0, 100]); theme['--surface-container-low'] = formatHSL([h, Math.min(s, 15), 96]); theme['--surface-container'] = formatHSL([h, Math.min(s, 15), 94]); theme['--surface-container-high'] = formatHSL([h, Math.min(s, 15), 92]); theme['--surface-container-highest'] = formatHSL([h, Math.min(s, 18), 90]); } theme['--tertiary'] = formatHSL([(h - 60 + 360) % 360, Math.max(s - 10, 40), l]); theme['--on-tertiary'] = darkMode ? formatHSL([(h - 60 + 360) % 360, Math.max(s - 30, 10), Math.max(l - 25, 20)]) : formatHSL([(h - 60 + 360) % 360, Math.min(s, 50), Math.min(l + 50, 100)]); if (!darkMode && l > 65) theme['--on-tertiary'] = formatHSL([(h - 60 + 360) % 360, Math.min(s, 70), Math.max(l - 50, 10)]); theme['--tertiary-container'] = darkMode ? formatHSL([(h - 60 + 360) % 360, Math.min(s - 10, 40), Math.max(l - 10, 35)]) : formatHSL([(h - 60 + 360) % 360, Math.max(s - 10, 50), Math.min(l + 40, 90)]); theme['--on-tertiary-container'] = darkMode ? formatHSL([(h - 60 + 360) % 360, Math.min(s, 80), Math.min(l + 40, 90)]) : formatHSL([(h - 60 + 360) % 360, Math.min(s, 70), Math.max(l - 20, 20)]); theme['--error'] = darkMode ? '#F2B8B5' : '#B3261E'; theme['--on-error'] = darkMode ? '#601410' : '#FFFFFF'; theme['--error-container'] = darkMode ? '#8C1D18' : '#F9DEDC'; theme['--on-error-container'] = darkMode ? '#F9DEDC' : '#410E0B'; theme['--shadow'] = '#000000'; return theme; }
        function applyThemeVariables(themeObject) { if (!htmlElement) return; for (const [key, value] of Object.entries(themeObject)) { htmlElement.style.setProperty(key, value); } if (themeColorMeta) { themeColorMeta.content = themeObject['--primary']; } }
        function applyPlayerTheme() { if (!players || !players.length || !htmlElement) return; const currentPlayer = players[currentPlayerIndex]; if (!currentPlayer) return; if (!currentPlayer.theme) { try { currentPlayer.theme = generateThemeColors(currentPlayer.color, isDarkMode); } catch (e) { console.error("Error generating theme for player", currentPlayer, e); return; } } const themeMatchesDarkMode = (currentPlayer.theme['--background'] === 'var(--oled-bg)' && isDarkMode) || (currentPlayer.theme['--background'] !== 'var(--oled-bg)' && !isDarkMode); if (!themeMatchesDarkMode) { try { currentPlayer.theme = generateThemeColors(currentPlayer.color, isDarkMode); } catch (e) { console.error("Error regenerating theme for player", currentPlayer, e); return; } } if (currentPlayer.theme) { applyThemeVariables(currentPlayer.theme); } }
        function updateDarkModeToggleIcon() { if (!darkModeToggle) return; const icon = darkModeToggle.querySelector('i'); if (icon) { if (isDarkMode) { icon.classList.remove('fa-sun'); icon.classList.add('fa-moon'); } else { icon.classList.remove('fa-moon'); icon.classList.add('fa-sun'); } } }
        function toggleDarkMode() { isDarkMode = !isDarkMode; htmlElement.classList.toggle('dark', isDarkMode); try { localStorage.setItem(LS_DARK_MODE_KEY, isDarkMode); } catch (e) { console.error("Dark Mode state konnte nicht gespeichert werden.", e); } updateDarkModeToggleIcon(); applyPlayerTheme(); }
        function initializeDarkMode() { try { const storedDarkMode = localStorage.getItem(LS_DARK_MODE_KEY); isDarkMode = storedDarkMode === 'true'; } catch (e) { console.error("Dark Mode state konnte nicht geladen werden.", e); isDarkMode = window.matchMedia?.('(prefers-color-scheme: dark)')?.matches ?? false; } if (htmlElement) htmlElement.classList.toggle('dark', isDarkMode); updateDarkModeToggleIcon(); }
        function getSavedPlayerNames() { try { const names = localStorage.getItem(LS_PLAYERS_KEY); return names ? JSON.parse(names) : []; } catch (e) { console.error("Laden der Spielernamen fehlgeschlagen:", e); return []; } }
        function savePlayerNames(names) { try { localStorage.setItem(LS_PLAYERS_KEY, JSON.stringify(names)); } catch (e) { console.error("Speichern der Spielernamen fehlgeschlagen:", e); displayMessage("Speichern der Namen nicht möglich."); } }
        function loadPlayerNames() { if (!playerCountSelect) return; console.log("Loading player names..."); const savedNames = getSavedPlayerNames(); if (savedNames.length > 0) { if (savedNames.length <= playerCountSelect.options.length) { playerCountSelect.value = savedNames.length; } setupPlayerInputs(); } else { setupPlayerInputs(); } console.log("Player names loaded."); }

        // --- INITIALIZATION (Unchanged) ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed");
            if (!playerSetupSection || !playerCountSelect || !playerNamesContainer || !startGameBtn || !gameHistorySection || !historyContent || !gameArea || !diceContainer || !rollBtn || !scorecardTable || !gameOverOverlay || !darkModeToggle || !scorecardBody || !scorecardFoot) { console.error("FEHLER: Eines oder mehrere essentielle HTML-Elemente wurden nicht gefunden! Überprüfe die IDs im HTML."); alert("Initialisierungsfehler! Wichtige Spielelemente fehlen. Bitte überprüfe die HTML-Struktur oder die Konsole."); return; }
            try {
                initializeDarkMode();
                setupPlayerInputs();
                loadPlayerNames();
                displayHistory();
                playerCountSelect.addEventListener('change', setupPlayerInputs);
                startGameBtn.addEventListener('click', startGame);
                rollBtn.addEventListener('click', rollDice);
                diceContainer.addEventListener('click', toggleHoldDice);
                scorecardBody.addEventListener('click', handleScorecardClick);
                restartGameBtn.addEventListener('click', restartGame);
                darkModeToggle.addEventListener('click', toggleDarkMode);
                renderDice();
                console.log("Event listeners attached.");
                if ('serviceWorker' in navigator) { navigator.serviceWorker.register('sw.js').then(registration => console.log('Service Worker registered:', registration.scope)).catch(error => console.log('Service Worker registration failed:', error)); } else { console.log("Service Worker not supported."); }
                if (players.length > 0) { applyPlayerTheme(); } else { applyThemeVariables(generateThemeColors(playerColors[0], isDarkMode)); }
            } catch (error) { console.error("FEHLER bei der Initialisierung des Spiels:", error); alert("Ein Fehler ist bei der Initialisierung aufgetreten. Bitte prüfe die Konsole für Details."); }
        });

        // --- PLAYER SETUP (Unchanged) ---
        function setupPlayerInputs() {
            console.log("Setting up player inputs...");
            const count = parseInt(playerCountSelect.value);
            playerNamesContainer.innerHTML = '';
            const savedNames = getSavedPlayerNames();
            for (let i = 0; i < count; i++) {
                const inputId = `playerName${i + 1}`;
                const savedName = savedNames[i] || `Spieler ${i + 1}`;
                const playerColor = playerColors[i % playerColors.length];
                const div = document.createElement('div');
                div.innerHTML = `<label for="${inputId}" class="flex items-center"><span class="w-4 h-4 rounded-full mr-2 inline-block" style="background-color: ${playerColor}; border: 1px solid grey;"></span> Spieler ${i + 1}:</label><input type="text" id="${inputId}" value="${savedName}" placeholder="Name eingeben" class="w-full">`;
                playerNamesContainer.appendChild(div);
            }
        }

        // --- GAME LOGIC (Unchanged) ---
        function startGame() {
            console.log("Starting game...");
            try {
                players = [];
                const nameInputs = playerNamesContainer.querySelectorAll('input');
                const playerNamesToSave = [];
                nameInputs.forEach((input, index) => { const name = input.value.trim() || `Spieler ${index + 1}`; const color = playerColors[index % playerColors.length]; const player = { id: `p${index}`, name: name, color: color, theme: null }; players.push(player); playerNamesToSave.push(name); });
                if (players.length === 0) { displayMessage("Bitte mindestens einen Spieler hinzufügen."); return; }
                savePlayerNames(playerNamesToSave);
                currentPlayerIndex = 0; currentRoll = 0; round = 1; diceValues = Array(NUM_DICE).fill(1); heldDice = Array(NUM_DICE).fill(false); scores = {}; ziffarBonus = {};
                players.forEach(p => { scores[p.id] = {}; CATEGORIES.forEach(cat => scores[p.id][cat.id] = null); ziffarBonus[p.id] = 0; });
                potentialScores = {};
                playerSetupSection.classList.add('hidden'); gameHistorySection.classList.add('hidden'); gameArea.classList.remove('hidden'); gameOverOverlay.classList.remove('show'); gameOverOverlay.classList.add('hidden');
                setupScorecard(); applyPlayerTheme(); updateGameInfo(); resetDiceAppearance();
                if (rollBtn) { rollBtn.disabled = false; rollBtn.textContent = "Würfeln"; rollBtn.className = 'btn btn-primary'; }
                displayMessage("");
                console.log("Game started successfully.");
            } catch (error) { console.error("FEHLER beim Starten des Spiels:", error); alert("Spiel konnte nicht gestartet werden. Fehlerdetails in der Konsole."); }
        }
        function setupScorecard() {
            console.log("Setting up scorecard...");
            if (!scorecardTable || !scorecardBody || !scorecardFoot) { console.error("Scorecard table, body, or foot not found!"); return; }
            const thead = scorecardTable.querySelector('thead tr'); if (!thead) return; const tbody = scorecardBody; const tfoot = scorecardFoot;
            while (thead.cells.length > 1) thead.deleteCell(1); tbody.innerHTML = ''; tfoot.innerHTML = '';
            players.forEach((player) => { const th = document.createElement('th'); th.scope = 'col'; th.textContent = player.name; th.className = 'px-4 py-3 text-center player-header align-top'; th.dataset.playerId = player.id; thead.appendChild(th); });
            let currentSection = '';
            CATEGORIES.forEach(cat => {
                if (cat.section !== currentSection) { currentSection = cat.section; const sepRow = tbody.insertRow(); sepRow.className = 'score-section-header'; const sepCell = sepRow.insertCell(); sepCell.colSpan = players.length + 1; sepCell.textContent = currentSection === 'upper' ? 'Oberer Teil' : 'Unterer Teil'; sepCell.classList.add('sticky', 'left-0', 'z-10'); }
                const row = tbody.insertRow(); row.dataset.categoryId = cat.id;
                const nameCell = row.insertCell(); nameCell.className = 'px-4 py-2 font-medium whitespace-nowrap sticky left-0 bg-inherit z-10 align-top'; nameCell.innerHTML = `${cat.name}<span class="category-description">${cat.description}</span>`;
                players.forEach(player => { const scoreCell = row.insertCell(); scoreCell.className = 'px-4 py-2 text-center score-cell available align-middle'; scoreCell.dataset.playerId = player.id; scoreCell.dataset.categoryId = cat.id; scoreCell.textContent = '-'; scoreCell.setAttribute('aria-label', `Punkte für ${cat.name} für ${player.name} eintragen`); scoreCell.setAttribute('role', 'button'); scoreCell.tabIndex = 0; });
            });
            const summaryRowsData = [{ id: 'upperBonusRow', nameHtml: `Bonus <span class="text-xs font-normal">(ab ${UPPER_BONUS_THRESHOLD} P.)</span><span class="category-description">Bei ${UPPER_BONUS_THRESHOLD}+ P. oben: ${UPPER_BONUS_POINTS} extra.</span>`, dataAttr: 'upperBonus', class: 'font-semibold' }, { id: 'upperTotalRow', nameHtml: `Summe Oben`, dataAttr: 'upperTotal', class: 'font-semibold' }, { id: 'ziffarBonusRow', nameHtml: `Ziffar Bonus<span class="category-description">Pro weiterem Ziffar: ${ZIFFAR_BONUS_POINTS} extra.</span>`, dataAttr: 'ziffarBonus', class: 'font-semibold' }];
            summaryRowsData.forEach(rowData => { const row = tbody.insertRow(); row.id = rowData.id; const nameCell = row.insertCell(); nameCell.className = `px-4 py-2 font-medium whitespace-nowrap sticky left-0 bg-inherit z-10 align-top ${rowData.class}`; nameCell.innerHTML = rowData.nameHtml; players.forEach(player => { const cell = row.insertCell(); cell.className = `px-4 py-2 text-center align-middle ${rowData.class}`; cell.dataset.playerId = player.id; cell.id = `${rowData.dataAttr}-${player.id}`; cell.textContent = '0'; }); });
            const totalRow = tfoot.insertRow(); const totalNameCell = totalRow.insertCell(); totalNameCell.className = 'px-4 py-3 font-bold sticky left-0 bg-inherit z-10 align-middle'; totalNameCell.textContent = 'Gesamtpunktzahl';
            players.forEach(player => { const totalCell = totalRow.insertCell(); totalCell.className = 'px-4 py-3 text-center font-bold align-middle'; totalCell.dataset.playerId = player.id; totalCell.id = `totalScore-${player.id}`; totalCell.textContent = '0'; });
            console.log("Scorecard setup complete.");
        }
        function updateGameInfo() {
            if (!players || players.length === 0 || !currentPlayerNameSpan || !rollsLeftSpan || !currentRoundSpan) return;
            const currentPlayer = players[currentPlayerIndex]; if (!currentPlayer) return;
            currentPlayerNameSpan.textContent = currentPlayer.name; rollsLeftSpan.textContent = MAX_ROLLS - currentRoll; currentRoundSpan.textContent = round;
            document.querySelectorAll('#scorecard .player-header, #scorecard .score-cell, #scorecard tfoot td, #scorecard #upperBonusRow td, #scorecard #upperTotalRow td, #scorecard #ziffarBonusRow td').forEach(cell => cell.classList.remove('current-player-column'));
            document.querySelectorAll(`#scorecard [data-player-id="${currentPlayer.id}"]`).forEach(cell => cell.classList.add('current-player-column'));
        }
        function nextTurn() {
            console.log("Moving to next turn...");
            currentPlayerIndex = (currentPlayerIndex + 1) % players.length; currentRoll = 0; heldDice.fill(false); potentialScores = {};
            if (currentPlayerIndex === 0) { round++; }
            if (round > CATEGORIES.length) { endGame(); } else { applyPlayerTheme(); updateGameInfo(); resetDiceAppearance(); if (rollBtn) { rollBtn.disabled = false; rollBtn.textContent = "Würfeln"; rollBtn.className = 'btn btn-primary'; } displayMessage(""); clearPotentialScores(true); }
        }
        function endGame() {
            console.log("Ending game...");
            if (rollBtn) { rollBtn.disabled = true; rollBtn.className = 'btn btn-primary'; }
            displayMessage("Spiel vorbei!", "info");
            let winningScore = -1; let winners = []; const finalPlayerData = [];
            const finalScoresHTML = players.map(player => { const totalScoreCell = document.getElementById(`totalScore-${player.id}`); const score = parseInt(totalScoreCell?.textContent || '0'); finalPlayerData.push({ name: player.name, score: score }); if (score > winningScore) { winningScore = score; winners = [player.name]; } else if (score === winningScore) { winners.push(player.name); } return `<p class="flex justify-between"><span class="font-semibold">${player.name}:</span> <span>${score} Punkte</span></p>`; }).join('');
            if (finalScoresDiv) finalScoresDiv.innerHTML = finalScoresHTML;
            if (winnerMessage) { if (winners.length === 1) { winnerMessage.textContent = `${winners[0]} hat gewonnen! ✨`; } else if (winners.length > 1) { winnerMessage.textContent = `Unentschieden zwischen ${winners.join(' & ')}!`; } else { winnerMessage.textContent = `Kein Gewinner? 🤔`; } }
            const gameResult = { date: new Date().toISOString(), players: finalPlayerData, winnerNames: winners };
            addGameToHistory(gameResult);
            if (gameOverOverlay) { gameOverOverlay.classList.remove('hidden'); gameOverOverlay.classList.add('show'); }
        }
        function restartGame() {
            console.log("Restarting game...");
            if (gameOverOverlay) { gameOverOverlay.classList.remove('show'); gameOverOverlay.classList.add('hidden'); }
            if (gameArea) gameArea.classList.add('hidden');
            if (playerSetupSection) playerSetupSection.classList.remove('hidden'); if (gameHistorySection) gameHistorySection.classList.remove('hidden');
            loadPlayerNames(); displayHistory();
            if (players.length > 0) { applyPlayerTheme(); } else { applyThemeVariables(generateThemeColors(playerColors[0], isDarkMode)); }
        }
        function renderPotentialScores() {
            if (!scorecardBody || !players || players.length === 0) return; clearPotentialScores(false);
            const currentPlayer = players[currentPlayerIndex]; if (!currentPlayer) return;
            const defaultAriaLabel = (catName) => `Punkte für ${catName} für ${currentPlayer.name} eintragen`;
            Object.entries(potentialScores).forEach(([categoryId, score]) => {
                if (score !== null) { const cell = scorecardBody.querySelector(`.score-cell[data-player-id="${currentPlayer.id}"][data-category-id="${categoryId}"]`); if (cell && !cell.classList.contains('filled')) { cell.textContent = score; const catName = CATEGORIES.find(c => c.id === categoryId)?.name || categoryId; if (score > 0) { cell.classList.add('potential'); cell.setAttribute('aria-label', `Mögliche Punkte für ${catName}: ${score}. Klicken zum Eintragen.`); } else { cell.classList.remove('potential'); cell.setAttribute('aria-label', defaultAriaLabel(catName)); } } }
            });
        }
        function clearPotentialScores(clearAllPlayers = false) {
            if (!scorecardBody || !players || players.length === 0) return;
            const targetPlayerIds = clearAllPlayers ? players.map(p => p.id) : (players[currentPlayerIndex] ? [players[currentPlayerIndex].id] : []); if (targetPlayerIds.length === 0) return;
            targetPlayerIds.forEach(playerId => { const player = players.find(p => p.id === playerId); const playerName = player ? player.name : ''; const availableCells = scorecardBody.querySelectorAll(`.score-cell[data-player-id="${playerId}"]:not(.filled)`); availableCells.forEach(cell => { cell.classList.remove('potential'); cell.textContent = '-'; const categoryId = cell.dataset.categoryId; const catName = CATEGORIES.find(c => c.id === categoryId)?.name || categoryId; cell.setAttribute('aria-label', `Punkte für ${catName} für ${playerName} eintragen`); }); });
        }
        function getGameHistory() { try { const history = localStorage.getItem(LS_GAME_HISTORY_KEY); return history ? JSON.parse(history) : []; } catch (e) { console.error("Laden der Spielhistorie fehlgeschlagen:", e); return []; } }
        function saveGameHistory(history) { try { localStorage.setItem(LS_GAME_HISTORY_KEY, JSON.stringify(history)); } catch (e) { console.error("Speichern der Spielhistorie fehlgeschlagen:", e); displayMessage("Speichern der Historie nicht möglich."); } }
        function addGameToHistory(gameResult) { const history = getGameHistory(); history.unshift(gameResult); saveGameHistory(history); }
        function displayHistory() {
            if (!historyContent || !gameHistorySection) return; const history = getGameHistory(); historyContent.innerHTML = '';
            if (history.length === 0) { historyContent.innerHTML = '<p class="text-center text-on-surface-variant">Noch keine Spiele gespielt.</p>'; gameHistorySection.classList.remove('hidden'); return; }
            gameHistorySection.classList.remove('hidden'); const historyList = document.createElement('ul'); const winCounts = {};
            history.forEach(game => { const li = document.createElement('li'); const dateString = new Date(game.date).toLocaleString('de-DE', { dateStyle: 'short', timeStyle: 'short' }); let playersHtml = game.players.map(p => `${p.name}: ${p.score}`).join(' | '); let winnerHtml = ''; if (game.winnerNames.length === 1) { winnerHtml = `<span class="history-winner">Gewinner: ${game.winnerNames[0]}</span>`; winCounts[game.winnerNames[0]] = (winCounts[game.winnerNames[0]] || 0) + 1; } else if (game.winnerNames.length > 1) { winnerHtml = `<span class="history-winner">Unentschieden: ${game.winnerNames.join(' & ')}</span>`; } li.innerHTML = `<span class="history-date">${dateString}</span><span>${playersHtml}</span><br>${winnerHtml}`; historyList.appendChild(li); });
            const statsDiv = document.createElement('div'); statsDiv.id = 'historyStats'; statsDiv.innerHTML = '<h3>Statistik (Siege)</h3>'; const statsList = document.createElement('ul'); const sortedWins = Object.entries(winCounts).sort(([, a], [, b]) => b - a);
            if (sortedWins.length > 0) { sortedWins.forEach(([name, count]) => { const statLi = document.createElement('li'); statLi.textContent = `${name}: ${count} Sieg${count > 1 ? 'e' : ''}`; statsList.appendChild(statLi); }); } else { statsList.innerHTML = '<li class="text-on-surface-variant">Noch keine eindeutigen Siege.</li>'; }
            statsDiv.appendChild(statsList); historyContent.appendChild(historyList); historyContent.appendChild(statsDiv);
        }
        function renderDice() {
            if (!diceContainer) return; diceContainer.innerHTML = '';
            diceValues.forEach((value, index) => { const die = document.createElement('div'); die.className = 'dice'; die.dataset.index = index; die.dataset.value = value; die.setAttribute('aria-label', `Würfel ${index + 1} zeigt ${value}${heldDice[index] ? ', gehalten' : ''}`); die.setAttribute('role', 'button'); die.tabIndex = 0; if (heldDice[index]) { die.classList.add('held'); } die.innerHTML = `<span class="pip top-left"></span><span class="pip top-right"></span><span class="pip middle-left"></span><span class="pip center"></span><span class="pip middle-right"></span><span class="pip bottom-left"></span><span class="pip bottom-right"></span>`; diceContainer.appendChild(die); });
        }
        function resetDiceAppearance() {
            if (!diceContainer) return; diceContainer.innerHTML = ''; diceValues.fill(1); heldDice.fill(false);
            for (let i = 0; i < NUM_DICE; i++) { const die = document.createElement('div'); die.className = 'dice'; die.dataset.index = i; die.dataset.value = 1; die.setAttribute('aria-label', `Würfel ${i + 1} zeigt 1`); die.setAttribute('role', 'button'); die.tabIndex = 0; die.innerHTML = `<span class="pip top-left"></span><span class="pip top-right"></span><span class="pip middle-left"></span><span class="pip center"></span><span class="pip middle-right"></span><span class="pip bottom-left"></span><span class="pip bottom-right"></span>`; diceContainer.appendChild(die); }
        }
        function toggleHoldDice(event) {
            const die = event.target.closest('.dice'); if (!die || currentRoll === 0) return;
            const index = parseInt(die.dataset.index); heldDice[index] = !heldDice[index]; die.classList.toggle('held');
            const value = die.dataset.value; die.setAttribute('aria-label', `Würfel ${index + 1} zeigt ${value}${heldDice[index] ? ', gehalten' : ''}`);
        }
        function handleScorecardClick(event) {
            const cell = event.target.closest('.score-cell'); if (!cell) return;
            if (currentRoll === 0) { if (!cell.classList.contains('filled')) displayMessage("Du musst zuerst würfeln!"); return; }
            const playerId = cell.dataset.playerId; const categoryId = cell.dataset.categoryId;
            if (!players || players.length === 0) return; const currentPlayer = players[currentPlayerIndex]; if (!currentPlayer) return;
            if (playerId !== currentPlayer.id) { displayMessage("Warte, bis du dran bist!"); return; }
            if (scores[playerId]?.[categoryId] !== null) { displayMessage("Diese Kategorie wurde bereits gewählt."); return; }
            const score = potentialScores[categoryId] ?? calculateScoreForCategory(categoryId, diceValues);
            scores[playerId][categoryId] = score;
            const isZiffar = checkZiffar(diceValues);
            if (categoryId === 'ziffar' && isZiffar) { ziffarBonus[playerId]++; } else if (isZiffar && scores[playerId]?.['ziffar'] !== null && scores[playerId]['ziffar'] > 0) { ziffarBonus[playerId]++; displayMessage(`Zusätzlicher Ziffar! ${ZIFFAR_BONUS_POINTS} Bonuspunkte!`, "info"); } else if (categoryId !== 'ziffar' && isZiffar && scores[playerId]?.['ziffar'] === 0) { const upperCategoryMap = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes']; const upperCategoryId = upperCategoryMap[diceValues[0] - 1]; if (scores[playerId]?.[upperCategoryId] === null && categoryId !== upperCategoryId) { if (ziffarBonus[playerId] >= 1) { ziffarBonus[playerId]++; displayMessage(`Ziffar Joker! ${ZIFFAR_BONUS_POINTS} Bonuspunkte!`, "info"); } } }
            updateScorecard(); clearPotentialScores(true); nextTurn();
        }
        function updateScorecard() {
            if (!scorecardBody || !players || players.length === 0) return;
            players.forEach(player => {
                if (!player) return; let upperScore = 0; let lowerScore = 0; let hasBonus = false;
                CATEGORIES.forEach(cat => { const score = scores[player.id]?.[cat.id]; const cell = scorecardBody.querySelector(`.score-cell[data-player-id="${player.id}"][data-category-id="${cat.id}"]`); if (cell) { if (score !== null) { cell.textContent = score; cell.classList.remove('available', 'potential'); cell.classList.add('filled'); cell.removeAttribute('role'); cell.removeAttribute('tabindex'); const catName = CATEGORIES.find(c => c.id === cat.id)?.name || cat.id; cell.setAttribute('aria-label', `${catName} für ${player.name}: ${score} Punkte`); if (cat.section === 'upper') upperScore += score; else lowerScore += score; } else { if (!cell.classList.contains('potential')) { cell.textContent = '-'; } cell.classList.remove('filled'); cell.classList.add('available'); cell.setAttribute('role', 'button'); cell.tabIndex = 0; const catName = CATEGORIES.find(c => c.id === cat.id)?.name || cat.id; cell.setAttribute('aria-label', `Punkte für ${catName} für ${player.name} eintragen`); } } });
                const upperTotalCell = document.getElementById(`upperTotal-${player.id}`); if (upperTotalCell) upperTotalCell.textContent = upperScore;
                const upperBonusCell = document.getElementById(`upperBonus-${player.id}`); if (upperBonusCell) { hasBonus = upperScore >= UPPER_BONUS_THRESHOLD; upperBonusCell.textContent = hasBonus ? UPPER_BONUS_POINTS : '0'; }
                const ziffarBonusCell = document.getElementById(`ziffarBonus-${player.id}`); const currentZiffarBonusPoints = (ziffarBonus[player.id] > 1 ? (ziffarBonus[player.id] - 1) : 0) * ZIFFAR_BONUS_POINTS; if (ziffarBonusCell) { ziffarBonusCell.textContent = currentZiffarBonusPoints; }
                const totalScoreCell = document.getElementById(`totalScore-${player.id}`); if (totalScoreCell) { const bonusPoints = hasBonus ? UPPER_BONUS_POINTS : 0; totalScoreCell.textContent = upperScore + bonusPoints + lowerScore + currentZiffarBonusPoints; }
            });
        }
        function displayMessage(msg, type = "error") { if (!gameMessage) return; gameMessage.textContent = msg; gameMessage.className = `mt-4 text-center font-medium h-6 ${type === 'error' ? 'text-error' : 'text-secondary'}`; gameMessage.setAttribute('role', 'alert'); gameMessage.setAttribute('aria-live', 'assertive'); }
        function countDice(dice) { const counts = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 }; dice.forEach(d => { if (d >= 1 && d <= 6) counts[d]++; }); return counts; }
        function checkZiffar(dice) { if (!dice || dice.length !== NUM_DICE || dice.some(d => d === undefined || d === null)) return false; const first = dice[0]; return dice.every(d => d === first); }
        function renderSingleDie(dieElement, value, isHeld) { if (!dieElement) return; dieElement.dataset.value = value; dieElement.classList.toggle('held', isHeld); dieElement.setAttribute('aria-label', `Würfel ${parseInt(dieElement.dataset.index) + 1} zeigt ${value}${isHeld ? ', gehalten' : ''}`); }

        // --- SCORING CALCULATIONS (Unchanged) ---
        function calculatePotentialScores() {
            potentialScores = {}; if (!players || players.length === 0 || !players[currentPlayerIndex]) { console.error("Kann mögliche Punkte nicht berechnen: Ungültige Spielerdaten."); return; } const currentPlayer = players[currentPlayerIndex];
            CATEGORIES.forEach(cat => { if (scores[currentPlayer.id]?.[cat.id] === null) { potentialScores[cat.id] = calculateScoreForCategory(cat.id, diceValues); } else { potentialScores[cat.id] = null; } });
        }
        function calculateScoreForCategory(categoryId, dice) {
            const counts = countDice(dice); const sortedDice = [...dice].sort(); const sum = dice.reduce((a, b) => a + b, 0);
            switch (categoryId) {
                case 'ones': return (counts[1] || 0) * 1; case 'twos': return (counts[2] || 0) * 2; case 'threes': return (counts[3] || 0) * 3; case 'fours': return (counts[4] || 0) * 4; case 'fives': return (counts[5] || 0) * 5; case 'sixes': return (counts[6] || 0) * 6;
                case 'threeOfAKind': return Object.values(counts).some(count => count >= 3) ? sum : 0; case 'fourOfAKind': return Object.values(counts).some(count => count >= 4) ? sum : 0;
                case 'fullHouse': const vals = Object.values(counts).filter(c => c > 0); return vals.length === 2 && vals.includes(3) ? 25 : 0;
                case 'smallStraight': const uniqueSorted = [...new Set(sortedDice)]; const straights = ['1234', '2345', '3456']; for (let i = 0; i <= uniqueSorted.length - 4; i++) { const sub = uniqueSorted.slice(i, i + 4); if (sub[3] === sub[0] + 3 && sub[2] === sub[0] + 2 && sub[1] === sub[0] + 1) { if (straights.includes(sub.join(''))) return 30; } } if (straights.some(s => s.split('').every(digit => uniqueSorted.includes(parseInt(digit))))) { return 30; } return 0;
                case 'largeStraight': const uniqueLG = [...new Set(sortedDice)]; const largeStraights = ['12345', '23456']; for (let i = 0; i <= uniqueLG.length - 5; i++) { const sub = uniqueLG.slice(i, i + 5); if (sub[4] === sub[0] + 4 && sub[3] === sub[0] + 3 && sub[2] === sub[0] + 2 && sub[1] === sub[0] + 1) { if (largeStraights.includes(sub.join(''))) return 40; } } return 0;
                case 'ziffar': return Object.values(counts).some(count => count >= 5) ? 50 : 0; case 'chance': return sum; default: return 0;
            }
        }

        // --- Dice Rolling & Rendering (Unchanged) ---
        function rollDice() {
            if (currentRoll >= MAX_ROLLS || !diceContainer || !rollBtn) return; displayMessage(""); currentRoll++;
            const diceElements = diceContainer.querySelectorAll('.dice'); let animationsPending = 0;
            diceValues.forEach((_, i) => {
                if (!heldDice[i]) {
                    animationsPending++; diceValues[i] = Math.floor(Math.random() * 6) + 1; const dieElement = diceElements[i];
                    if (dieElement) { void dieElement.offsetWidth; dieElement.classList.add('rolling'); setTimeout(() => { if (dieElement) { dieElement.classList.remove('rolling'); renderSingleDie(dieElement, diceValues[i], heldDice[i]); } animationsPending--; if (animationsPending === 0) { calculatePotentialScores(); renderPotentialScores(); } }, 500); } else { console.error(`Würfel-Element mit Index ${i} nicht gefunden!`); animationsPending--; }
                } else { const dieElement = diceElements[i]; if (dieElement) { renderSingleDie(dieElement, diceValues[i], heldDice[i]); } }
            });
            updateGameInfo();
            if (animationsPending === 0 && currentRoll > 0) { calculatePotentialScores(); renderPotentialScores(); }
            if (currentRoll === MAX_ROLLS) { rollBtn.disabled = true; rollBtn.textContent = "Wähle Kategorie"; rollBtn.className = 'btn btn-secondary'; displayMessage("Letzter Wurf! Wähle eine Kategorie.", "info"); } else { rollBtn.disabled = false; rollBtn.textContent = `Würfeln (${MAX_ROLLS - currentRoll} übrig)`; rollBtn.className = 'btn btn-primary'; }
        }

    </script>
</body>

</html>
